<!DOCTYPE html>
<html lang="zh-CN" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>前端工程体系白皮书 | A Primer for Engineers</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:opsz,wght@8..60,400;8..60,600&family=Inter:wght@400;500;700&family=Fira+Code:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    /* --- Systems-Level Design Language --- */
    :root {
      /* Typography */
      --font-serif: 'Source Serif 4', serif;
      --font-sans: 'Inter', sans-serif;
      --font-mono: 'Fira Code', monospace;

      /* Spacing & Layout */
      --space-unit: 8px;
      --space-xs: calc(0.5 * var(--space-unit));
      --space-sm: var(--space-unit);
      --space-md: calc(2 * var(--space-unit));
      --space-lg: calc(4 * var(--space-unit));
      --space-xl: calc(8 * var(--space-unit));
      --max-width: 850px;

      /* Radii & Borders */
      --radius: 6px;
      --border-width: 1px;

      /* Transitions */
      --transition-fast: 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);

      /* --- Theme Palette --- */
      /* Dark (Default) */
      --bg-dark: #121212;
      --surface-dark: #1E1E1E;
      --text-primary-dark: #E0E0E0;
      --text-secondary-dark: #A0A0A0;
      --border-dark: #333333;
      --accent-primary-dark: #BB86FC;
      --accent-secondary-dark: #03DAC6;
      --code-bg-dark: #2A2A2A;

      /* Light */
      --bg-light: #F5F5F5;
      --surface-light: #FFFFFF;
      --text-primary-light: #212121;
      --text-secondary-light: #616161;
      --border-light: #E0E0E0;
      --accent-primary-light: #6200EE;
      --accent-secondary-light: #018786;
      --code-bg-light: #EEEEEE;
    }
    
    html {
        scroll-behavior: smooth;
    }

    html[data-theme='dark'] {
      --bg: var(--bg-dark);
      --surface: var(--surface-dark);
      --text-primary: var(--text-primary-dark);
      --text-secondary: var(--text-secondary-dark);
      --border: var(--border-dark);
      --accent-primary: var(--accent-primary-dark);
      --accent-secondary: var(--accent-secondary-dark);
      --code-bg: var(--code-bg-dark);
    }

    html[data-theme='light'] {
      --bg: var(--bg-light);
      --surface: var(--surface-light);
      --text-primary: var(--text-primary-light);
      --text-secondary: var(--text-secondary-light);
      --border: var(--border-light);
      --accent-primary: var(--accent-primary-light);
      --accent-secondary: var(--accent-secondary-light);
      --code-bg: var(--code-bg-light);
    }
    
    body {
      font-family: var(--font-sans);
      background-color: var(--bg);
      color: var(--text-primary);
      margin: 0;
      padding: var(--space-lg);
      font-size: 17px;
      line-height: 1.8;
      transition: background-color var(--transition-fast), color var(--transition-fast);
      -webkit-font-smoothing: antialiased;
    }
    
    .container {
        max-width: var(--max-width);
        margin: 0 auto;
    }

    /* Header & Navigation */
    .masthead {
        text-align: center;
        padding-bottom: var(--space-lg);
        margin-bottom: var(--space-xl);
        border-bottom: var(--border-width) solid var(--border);
        position: relative;
    }
    .masthead h1 {
        font-family: var(--font-serif);
        font-size: 3rem;
        font-weight: 600;
        letter-spacing: -0.5px;
        margin: 0;
    }
    .masthead .subtitle {
        font-size: 1.25rem;
        color: var(--text-secondary);
        margin-top: var(--space-sm);
    }
    .theme-toggle {
        position: absolute;
        top: calc(-1 * var(--space-md));
        right: 0;
        background: transparent;
        border: none;
        color: var(--text-secondary);
        font-size: 1.5rem;
        cursor: pointer;
        padding: var(--space-sm);
        border-radius: 50%;
        transition: color var(--transition-fast), background-color var(--transition-fast);
    }
    .theme-toggle:hover {
        color: var(--text-primary);
        background-color: var(--surface);
    }

    /* Content Styling */
    section {
        background-color: var(--surface);
        border: var(--border-width) solid var(--border);
        border-radius: var(--radius);
        margin-bottom: var(--space-xl);
        padding: var(--space-lg) var(--space-xl);
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    section h2 {
        font-family: var(--font-serif);
        font-size: 2.25rem;
        font-weight: 600;
        margin: 0 0 var(--space-lg) 0;
        border-bottom: var(--border-width) solid var(--border);
        padding-bottom: var(--space-md);
    }
    section h3 {
        font-family: var(--font-sans);
        font-size: 1.5rem;
        font-weight: 700;
        margin: var(--space-lg) 0 var(--space-md) 0;
        color: var(--accent-secondary);
    }
    
    p, li {
        color: var(--text-secondary);
        text-align: justify;
    }
    strong {
        color: var(--text-primary);
        font-weight: 700;
    }
    em {
        color: var(--accent-primary);
        font-style: normal;
        font-weight: 500;
    }

    /* Code & Analogy Blocks */
    code {
      font-family: var(--font-mono);
      background-color: var(--code-bg);
      padding: 0.2em 0.4em;
      border-radius: 4px;
      font-size: 0.9em;
    }
    pre {
      background-color: var(--code-bg);
      border: var(--border-width) solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-md);
      overflow-x: auto;
    }
    .analogy {
      border-left: 4px solid var(--accent-primary);
      background-color: var(--code-bg);
      padding: var(--space-md);
      margin: var(--space-md) 0;
      border-radius: 0 var(--radius) var(--radius) 0;
    }
    .analogy p {
        margin: 0;
    }
    .analogy .analogy-label {
        font-weight: 700;
        color: var(--accent-primary);
        display: block;
        margin-bottom: var(--space-xs);
        font-family: var(--font-sans);
    }

    .toc {
        list-style: none;
        padding-left: 0;
    }
    .toc li a {
        color: var(--accent-primary);
        text-decoration: none;
        font-weight: 500;
        transition: color var(--transition-fast);
    }
    .toc li a:hover {
        text-decoration: underline;
    }

    .final-cta {
        text-align: center;
        border-top: var(--border-width) solid var(--border);
        padding-top: var(--space-lg);
        margin-top: var(--space-xl);
    }
    .final-cta p {
        font-size: 1.2rem;
    }

  </style>
</head>
<body>
<div class="container">
    <header class="masthead">
        <button id="themeToggle" title="Toggle Theme">🌙</button>
        <h1>前端工程体系白皮书</h1>
        <p class="subtitle">一份面向系统级工程师的 Web 应用构建原理指南</p>
    </header>

    <main>
        <section id="introduction">
            <h2>引言：从脚本到应用</h2>
            <p>欢迎。你来自 Python 和 C 的世界，这意味着你理解确定性、类型系统和编译的力量。你习惯于将源代码通过一个明确的过程（编译、解释）转换为一个可执行的产物。前端开发，尤其是现代前端开发，遵循着完全相同的哲学，只是它的“编译器”和“运行时”有些特殊。</p>
            <p>传统观念认为前端是“写脚本”，即直接编写在特定环境中（浏览器）解释执行的代码。这在过去是事实，但今天的复杂 Web 应用，如 Figma、Stripe Dashboard，其工程复杂度已不亚于任何桌面应用。它们不是“脚本”，而是被**构建 (Built)** 和 **编译 (Compiled)** 的复杂软件系统。</p>
            <p>本白皮书的目的，是为你揭示这个从源代码到最终用户界面（UI）的完整构建链条。我们将探讨每个工具在其中扮演的精确角色，并将其映射到你已有的工程知识上。</p>
            <h3>目录</h3>
            <ul class="toc">
                <li><a href="#part1">第一部分：通用执行环境 —— 浏览器及其原生指令集</a></li>
                <li><a href="#part2">第二部分：开发时运行时与包管理系统 —— Node.js & npm</a></li>
                <li><a href="#part3">第三部分：UI 抽象层与声明式范式 —— React</a></li>
                <li><a href="#part4">第四部分：现代化构建与开发工具链 —— Vite</a></li>
                <li><a href="#part5">第五部分：工作流整合 —— 从源代码到生产部署</a></li>
                <li><a href="#part6">第六部分：关键工程概念深化</a></li>
            </ul>
        </section>

        <section id="part1">
            <h2>第一部分：通用执行环境 —— 浏览器及其原生指令集</h2>
            <p>将浏览器想象成一个高度标准化的、跨平台的操作系统。它有自己的文件系统（源、缓存）、渲染引擎、网络堆栈，以及最重要的——一个**唯一的、内置的编程语言虚拟机**。要在这个“操作系统”上开发，我们必须理解它的三个原生“指令集”。</p>

            <h3>HTML: UI的抽象语法树 (AST)</h3>
            <p>HTML 文档并非仅仅是文本。当浏览器加载一个 <code>.html</code> 文件时，它会进行词法分析和语法分析，将其解析成一个内存中的树状数据结构——<strong>文档对象模型 (Document Object Model, DOM)</strong>。这个 DOM 就是 UI 的一种抽象语法树（AST）。</p>
            <p>它不是静态的。JavaScript 可以像操作任何数据结构一样，动态地增、删、改、查这个树上的节点。每一次修改，都会触发浏览器渲染引擎的重绘（Repaint）或重排（Reflow），从而更新用户看到的像素。</p>
            <div class="analogy">
                <span class="analogy-label">系统级类比</span>
                <p>将 HTML 源码看作 C 语言的 <code>.c</code> 文件，DOM 则是 Clang/GCC 解析后在内存中生成的 AST。后续的所有操作（如 JavaScript 的修改）和优化（如 React 的 V-DOM）都是基于这个树状结构进行的。</p>
            </div>

            <h3>CSS: 声明式的样式规则引擎</h3>
            <p>CSS 同样会被浏览器解析成一个树状结构——<strong>CSS 对象模型 (CSSOM)</strong>。渲染引擎会将 DOM 和 CSSOM 结合，生成一个**渲染树 (Render Tree)**，这个树只包含需要被渲染的可见节点及其样式。最后，布局（Layout）和绘制（Paint）阶段会根据渲染树计算出每个节点的精确位置和像素，并显示在屏幕上。</p>
            <p>CSS 的核心是其“层叠”（Cascading）和“继承”（Inheritance）的特性。这是一个高度复杂的、基于选择器特异性（Specificity）的规则匹配引擎。它是一种<strong>声明式</strong>语言：你只描述“什么元素应该是什么样子”，而不需要关心浏览器“如何实现”这个样式。</p>

            <h3>JavaScript: 唯一的原生脚本语言</h3>
            <p>这是最关键的一点：**JavaScript 是浏览器这个通用执行环境唯一原生支持的、可编程的语言。** 就像 x86 架构的 CPU 原生执行的是 x86 指令集一样，浏览器中的 JS 引擎（如 V8）原生执行的就是 JS 代码。</p>
            <p>所有其他试图在浏览器中运行的语言（包括你提到的 Python，通过 PyScript/Brython）都必须通过一个“中间层”：要么被编译成 JavaScript，要么在一个被编译成 WebAssembly（一种底层的、类似汇编的二进制格式）的解释器中运行。这两种方式都会带来额外的性能开销和生态系统的不兼容性。因此，在专业的前端工程领域，我们直接使用这门“母语”或其超集（TypeScript）。</p>
        </section>

        <section id="part2">
            <h2>第二部分：开发时运行时与包管理系统 —— Node.js & npm</h2>
            <p>既然 JS 只能在浏览器里运行，我们如何在开发机器上运行构建脚本、打包工具和代码检查器呢？这就是 Node.js 诞生的原因。</p>
            
            <h3>Node.js: 服务端（及开发时）的 JavaScript 运行时</h3>
            <p><code>Node.js</code> 本质上是把 Google Chrome 的 V8 JavaScript 引擎（一个用 C++ 编写的高性能 JS 虚拟机）拿了出来，并为其添加了文件系统访问、网络通信等原生操作系统接口。这使得 JavaScript 第一次获得了在服务器和开发者本地机器上运行的能力。</p>
            <p>对于前端开发而言，Node.js 的主要角色是作为我们**所有开发工具的运行时环境**。Vite、Webpack、ESLint、TypeScript 编译器... 所有这些工具本身都是用 JavaScript/TypeScript 编写的程序，它们需要在 Node.js 环境下才能执行。</p>
            <div class="analogy">
                <span class="analogy-label">系统级类比</span>
                <p><code>Node.js</code> 对于前端工具链，就像 <code>Python 解释器</code> 对于 `pip`, `Django`, `Flask` 一样，或者像 C 语言的运行时库和操作系统 API 对于 `make` 和 `gcc` 一样。它是在特定机器上执行特定语言代码的基础环境。</p>
            </div>
            
            <h3>npm: 前端生态的包管理器与项目清单</h3>
            <p>有了在本地运行 JS 的能力，就需要一个管理代码依赖的方式。<code>npm</code> (Node Package Manager) 应运而生，它与你熟悉的 `pip` 和 `micromamba` 承担着同样的角色。</p>
            <p>npm 包含两部分：</p>
            <ol>
                <li><strong>一个在线代码仓库 (The Registry):</strong> 类似于 PyPI (Python Package Index) 或 anaconda.org。这是全球最大的软件仓库，托管着数百万个可供下载的开源 JS 模块（包）。</li>
                <li><strong>一个命令行工具 (The CLI):</strong> 你在终端中使用的 <code>npm</code> 命令。它负责从仓库下载包，并管理项目的依赖。</li>
            </ol>
            <p>每个现代前端项目根目录下都有一个 <code>package.json</code> 文件。这个文件是项目的核心清单。</p>
            <div class="analogy">
                <span class="analogy-label">系统级类比</span>
                <p><code>package.json</code> 文件 ≈ <code>pyproject.toml</code> + <code>requirements.txt</code> + <code>Makefile</code>。它不仅定义了项目元数据和依赖项（如 React），还定义了可执行的脚本（如 <code>"dev": "vite"</code>），你可以通过 <code>npm run dev</code> 来执行。</p>
            </div>
        </section>

        <section id="part3">
            <h2>第三部分：UI 抽象层与声明式范式 —— React</h2>
            <p>直接手动操作 DOM（如 <code>element.appendChild()</code>）来构建复杂应用，就像用汇编语言编写大型软件。它可行，但极其繁琐、易错，且难以维护。当应用状态变得复杂时，你很难追踪是哪段代码在何时修改了哪个 UI 部分，导致 UI 和数据状态不一致。</p>

            <h3>React: UI 作为状态的纯函数映射</h3>
            <p>React 引入了一种革命性的范式：<strong>声明式 UI</strong>。其核心思想是，**UI 是应用程序状态（State）的一个纯函数映射：`UI = f(State)`**。</p>
            <p>你作为开发者，不再需要编写“如何从旧 UI 变到新 UI”的指令。你只需要：</p>
            <ol>
                <li>定义应用的所有可能状态。</li>
                <li>编写一个函数（即 React 组件），这个函数接收状态作为输入，并返回该状态下 UI 的描述。</li>
            </ol>
            <p>当状态发生变化时，React 框架会自动调用你的函数，计算出新的 UI 描述，然后<strong>高效地</strong>将这些变化应用到真实的 DOM 上。这让你从繁琐的 DOM 操作中解放出来，专注于业务逻辑和状态管理。</p>

            <h3>虚拟 DOM (Virtual DOM): 高效的 Diffing 与 Batching 机制</h3>
            <p>React 如何实现“高效地”更新 DOM？答案是**虚拟 DOM**。这是一个关键的性能优化机制。</p>
            <p>V-DOM 是一个纯粹的、轻量级的 JavaScript 对象，它是真实 DOM 结构的一个内存表示。当组件的状态改变时，会发生以下过程：</p>
            <ol>
                <li>React 重新运行组件函数，生成一个新的 V-DOM 树。</li>
                <li>React 将这个新的 V-DOM 树与它在内存中保存的上一个 V-DOM 树进行比较。这个过程称为**“Diffing”**（差异计算）。</li>
                <li>Diffing 算法会找出两棵树之间的最小差异集（例如，“这个文本节点的内容变了”、“这里新增了一个 `<li>` 元素”）。</li>
                <li>React 将这些差异操作打包（**Batching**），然后一次性地、以最优化的方式去执行真实的 DOM 修改。</li>
            </ol>
            <div class="analogy">
                <span class="analogy-label">系统级类比</span>
                <p>这类似于编译器优化。你写的是高级 C 代码，但编译器不会逐字翻译成汇编。它会先生成中间表示（IR），在 IR 层面进行各种优化（死代码消除、循环展开等），最后才生成最优化的机器码。V-DOM 就是 React 的“中间表示”，Diffing 和 Batching 就是它的“优化过程”。</p>
            </div>

            <h3>JSX: UI 描述的语法糖</h3>
            <p>你在 React 代码中看到的类似 HTML 的语法，称为 JSX (JavaScript XML)。<strong>它不是 HTML，也不是模板语言。</strong> 它是一种 JavaScript 的语法扩展，是一种“语法糖”。</p>
            <p>构建工具（如 Vite）会在编译时将 JSX 转换为常规的 JavaScript 函数调用。例如：</p>
            <pre><code>// 你写的 JSX:
const element = &lt;h1 className="greeting"&gt;Hello, world!&lt;/h1&gt;;

// 编译后实际的 JavaScript:
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);</code></pre>
            <p>JSX 的价值在于它让 UI 的树状结构在代码中一目了然，极大地提高了代码的可读性。</p>
        </section>

        <section id="part4">
            <h2>第四部分：现代化构建与开发工具链 —— Vite</h2>
            <p>我们不能直接把包含 JSX 和 TypeScript 的源代码文件扔给浏览器，因为它不认识这些语法。我们需要一个**构建过程 (Build Process)**，将我们的开发时代码转换为浏览器可执行的生产时代码。Vite 就是目前最先进的构建工具之一。</p>

            <h3>Vite: 新一代前端工具</h3>
            <p>Vite 扮演两个角色：一个**开发服务器**和一个**生产打包器**。</p>
            
            <h3>开发模式 (`npm run dev`)</h3>
            <p>Vite 的革命性之处在于其开发服务器的速度。传统的构建工具（如 Webpack）在启动时或每次代码改动时，都需要重新打包整个应用的所有模块，这在大型项目中可能需要几十秒甚至几分钟。</p>
            <p>Vite 另辟蹊径：它利用了现代浏览器原生支持的 <strong>ES 模块 (ESM)</strong>。它在启动时几乎不做任何打包工作。当浏览器请求某个文件时（比如 `App.tsx`），Vite 服务器会实时地拦截请求，即时地将该文件编译（如 TSX -> JS），然后返回给浏览器。浏览器根据文件中的 `import` 语句再去请求下一个模块。这种按需编译的方式，使得开发服务器的启动和更新速度达到了毫秒级别。</p>

            <h3>生产模式 (`npm run build`)</h3>
            <p>当准备部署应用时，碎片化的模块请求不利于网络性能。因此，在生产构建时，Vite 会执行传统的打包优化流程。它使用一个名为 **Rollup** 的高效打包器，将你的所有代码：</p>
            <ul>
                <li><strong>转译 (Transpile):</strong> 将 TypeScript 和 JSX 转换为兼容性更好的 JavaScript。</li>
                <li><strong>打包 (Bundle):</strong> 将多个 JS 模块合并成少数几个文件，减少 HTTP 请求次数。</li>
                <li><strong>压缩 (Minify):</strong> 移除所有不必要的字符（空格、注释），缩短变量名，减小文件体积。</li>
                <li><strong>摇树 (Tree-shaking):</strong> 分析代码，自动移除你 `import` 了但未实际使用的“死代码”。</li>
            </ul>
            <div class="analogy">
                <span class="analogy-label">系统级类比</span>
                <p>Vite 的开发模式像一个 JIT (Just-In-Time) 编译器，按需快速编译，追求开发速度。其生产模式则像一个 AOT (Ahead-Of-Time) 编译器，进行深度优化，追求最终产物的极致性能，类似于 C++ 编译时的 Release 模式 (`-O3` 优化等级)。</p>
            </div>
            <p>最终，这个过程会生成一个 `dist` 文件夹，里面包含一个 `index.html` 和一些高度优化的、静态的 CSS 和 JS 文件。这才是我们最终部署到服务器上的东西。</p>
        </section>
        
        <section id="part5">
            <h2>第五部分：工作流整合 —— 从源代码到生产部署</h2>
            <p>现在，我们可以将整个流程串联起来：</p>
            <ol>
                <li><strong>环境设置：</strong> 在你的开发机上安装 <strong>Node.js</strong>。</li>
                <li><strong>项目初始化：</strong> 使用 <code>npm create vite@latest my-app -- --template react-ts</code> 命令。<strong>npm</strong> 会从仓库下载 <strong>Vite</strong> 的脚手架工具，并创建一个包含 <strong>React</strong> 和 <strong>TypeScript</strong> 基础配置的项目结构。</li>
                <li><strong>依赖安装：</strong> 进入项目目录，运行 <code>npm install</code>。<strong>npm</strong> 会读取 <code>package.json</code> 文件，下载所有必需的库（如 react, framer-motion）到 <code>node_modules</code> 文件夹。</li>
                <li><strong>开发循环：</strong> 运行 <code>npm run dev</code>。<strong>Vite</strong> 启动开发服务器。你在 VS Code 中编写 <code>.tsx</code> 组件文件，保存时 Vite 会即时编译并在浏览器中热更新，你立即看到效果。</li>
                <li><strong>生产构建：</strong> 开发完成后，运行 <code>npm run build</code>。<strong>Vite</strong> 调用其内部的 Rollup 和其他工具，执行转译、打包、压缩等一系列优化，生成最终的 `dist` 文件夹。</li>
                <li><strong>部署：</strong> 将 `dist` 文件夹中的所有静态文件（<strong>HTML, CSS, JS</strong>）上传到任何静态文件服务器。当用户访问时，浏览器下载这些文件并执行 JS，<strong>React</strong> 开始工作，在客户端动态构建出完整的用户界面。</li>
            </ol>
        </section>

        <section id="part6">
            <h2>第六部分：关键工程概念深化</h2>
            <ul>
                <li><strong>TypeScript:</strong> 对于你来说，这应该是最容易接受的概念。它为动态的 JavaScript 带来了静态类型检查。这就像 C 语言的头文件（<code>.h</code>）提供了函数签名和类型定义一样，它是一种**代码契约**，能够在编译时（而不是运行时）捕获大量错误，并极大地提升了大型项目的可维护性和代码智能提示的准确性。</li>
                <li><strong>组件生命周期与副作用 (Side Effects):</strong> React 组件不仅仅是渲染函数，它们还有生命周期（挂载、更新、卸载）。任何与外部世界交互的操作，如 API 请求（数据获取）、手动 DOM 操作、设置定时器等，都被称为“副作用”。在 React 中，我们使用一个名为 `useEffect` 的 Hook 来管理这些副作用，确保它们在组件生命周期的正确时机执行。</li>
                <li><strong>状态管理 (State Management):</strong> 当应用变得复杂，许多组件需要共享和修改同一份数据时，仅仅依靠组件内部的 `useState` 会变得混乱。这时就需要专门的全局状态管理库，如 Redux 或 Zustand。它们提供了一个独立于组件树的、中心化的、可预测的状态容器。这类似于在后端应用中，你不会将业务状态散落在各个函数里，而是会设计一个专门的服务层或数据访问层来统一管理。</li>
                <li><strong>单页应用 (SPA) vs 多页应用 (MPA):</strong> 你的 `v9.html` 是一个 MPA（尽管只有一个页面）。每次导航（如果有多页）都会从服务器请求一个全新的 HTML 文档。而基于 React 构建的 SPA，初始只加载一个 HTML“空壳”。后续所有页面切换（路由）都由前端的 JavaScript 在内部处理，它只获取必要的数据，然后动态地卸载旧组件、挂载新组件来改变视图。这提供了更快、更流畅的、类似桌面应用的体验。</li>
            </ul>
        </section>

        <div class="final-cta">
            <p>理论的构建已经完成。现在，是时候亲手启动这个工程体系了。</p>
            <pre><code># 1. 创建你的第一个现代化前端项目
npm create vite@latest my-knowledge-engine -- --template react-ts

# 2. 进入项目目录
cd my-knowledge-engine

# 3. 安装所有依赖
npm install

# 4. 启动开发服务器
npm run dev</code></pre>
            <p>在浏览器中打开 Vite 提供的地址，然后开始用组件化的思维，将你的知识引擎重塑为一个可长期演进的系统。欢迎来到现代前端工程的世界。</p>
        </div>
    </main>
</div>

<script>
    const themeToggle = document.getElementById('themeToggle');
    const html = document.documentElement;

    const applyTheme = (theme) => {
      html.setAttribute('data-theme', theme);
      themeToggle.textContent = theme === 'dark' ? '☀️' : '🌙';
      localStorage.setItem('theme', theme);
    };

    const toggleTheme = () => {
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';
      applyTheme(newTheme);
    };

    // Initialize theme
    const storedTheme = localStorage.getItem('theme');
    const preferredTheme = window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark';
    const initialTheme = storedTheme || preferredTheme;
    applyTheme(initialTheme);
    
    themeToggle.addEventListener('click', toggleTheme);
</script>
</body>
</html>